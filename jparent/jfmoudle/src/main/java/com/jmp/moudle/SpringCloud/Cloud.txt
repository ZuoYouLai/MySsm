


微服务：
     1.一系列微小的服务共同组成
     2.跑在自己的进程里
     3.每个服务为独立的业务开发
     4.独立部署
     5.分布式管理



单体架构的缺点：
     1.开发效率低
     2.代码维护难
     3.部署不灵活
     4.稳定性不高
     5.扩展性不够


注册中心：
       客户端注册
       服务端注册



spring cloud 与 SOA 相差的是：消息总线

spring cloud：
    1.Eureka 注册服务：类似zookeeper一样，注册相应的服务内容
                       记录各个服务地址与端口信息，达到注册效果

    2.微服务中的服务与服务之间的调用是Http方式进行调用，与RPC方式不一样

    3.负载均衡器 ：Ribbion 分为：提供的策略：轮询Round Robin、随机Random、ResponseTime加权

    4.Feign使用 ： 底层也是一个http的请求方式来的，写法很不一样
                   1.在client端写一个接口加注解的方式进行调用
                   For Example：

                      @FeignClient(name = "${serviceName}")
                      public interface HotService
                      {
                          @RequestMapping(value = "/term/hot", method = RequestMethod.POST)
                          public Map<String, Object> hot(MultiValueMap params);
                      }
                      注意到上面提到的consumes参数去掉了，用了MultiValueMap就没必要再设置了
                      相应的，调用方式也要改变：
                      LinkedMultiValueMap<String, Object> multiValueMap = new LinkedMultiValueMap<>();
                      multiValueMap.add("terms", terms);
                      Map<String, Object> result = hotService.hot(multiValueMap);

                      作者：Carlyle1993
                      链接：https://www.jianshu.com/p/b63713879953
                      來源：简书
                      简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

       5.多个moudle开发

       6.同步与异步 ： 消息队列

       7.微服务与容器技术 --- 》 docker 与 devops 【例如炒菜跟盐一样】


       8.Config Server（统一的配置中心）
         原理：
             config server根据指定的代码的仓库来下载对应的配置文件，进行更新指向根据config server的服务进行更新文件内容，
             由于这里的web容器加载配置文件，内存是有相关的配置内容。需要spring cloud bus总线来进行通知，更新仓库的信息的时候
             然后再访问对应的/refrsh/bus进行消息队列的方式进行异步更新，更新内存的配置文件，更好的是git仓库中有web Hook动态的push，进行调用这个接口（post），
             这个接口名称对内为/refrsh/bus  对外的话则为：/monitor



